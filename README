!=====================================================================
!
!               S p e c f e m 3 D  V e r s i o n  1 . 4
!               ---------------------------------------
!
!                 Dimitri Komatitsch and Jeroen Tromp
!    Seismological Laboratory - California Institute of Technology
!         (c) California Institute of Technology September 2006
!
! This program is free software; you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation; either version 2 of the License, or
! (at your option) any later version.
!
! This program is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License along
! with this program; if not, write to the Free Software Foundation, Inc.,
! 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
!
!=====================================================================
!
!=============================================================================!
!                                                                             !
!  specfem3D is a 3-D spectral-element solver for a local or regional model.  !
!  It uses a mesh generated by program generate_databases                              !
!                                                                             !
!=============================================================================!

Instructions on how to install and use SPECFEM3D are
available in the manual located in directory doc/USER_MANUAL
and in file INSTALL.

Main developers: Dimitri Komatitsch and Jeroen Tromp

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+++++++++ NOTES ON USING THE SPECFEM3D PACKAGE +++++++++++
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

! If you use this code for your own research, please cite at least one article
! written by the developers of the package, for instance:
!
! @ARTICLE{TrKoLi08,
! author = {Jeroen Tromp and Dimitri Komatitsch and Qinya Liu},
! title = {Spectral-Element and Adjoint Methods in Seismology},
! journal = {Communications in Computational Physics},
! year = {2008},
! volume = {3},
! pages = {1-32},
! number = {1}}
!
! or
!
! @ARTICLE{LiPoKoTr04,
! author = {Qinya Liu and Jascha Polet and Dimitri Komatitsch and Jeroen Tromp},
! title = {Spectral-element moment tensor inversions for earthquakes in {S}outhern {C}alifornia},
! journal={Bull. Seismol. Soc. Am.},
! year = {2004},
! volume = {94},
! pages = {1748-1761},
! number = {5},
! doi = {10.1785/012004038}}
!
! @INCOLLECTION{ChKoViCaVaFe07,
! author = {Emmanuel Chaljub and Dimitri Komatitsch and Jean-Pierre Vilotte and
! Yann Capdeville and Bernard Valette and Gaetano Festa},
! title = {Spectral Element Analysis in Seismology},
! booktitle = {Advances in Wave Propagation in Heterogeneous Media},
! publisher = {Elsevier - Academic Press},
! year = {2007},
! editor = {Ru-Shan Wu and Val\'erie Maupin},
! volume = {48},
! series = {Advances in Geophysics},
! pages = {365-419}}
!
! @ARTICLE{KoVi98,
! author={D. Komatitsch and J. P. Vilotte},
! title={The spectral-element method: an efficient tool to simulate the seismic response of 2{D} and 3{D} geological structures},
! journal={Bull. Seismol. Soc. Am.},
! year=1998,
! volume=88,
! number=2,
! pages={368-392}}
!
! @ARTICLE{KoTr99,
! author={D. Komatitsch and J. Tromp},
! year=1999,
! title={Introduction to the spectral-element method for 3-{D} seismic wave propagation},
! journal={Geophys. J. Int.},
! volume=139,
! number=3,
! pages={806-822},
! doi={10.1046/j.1365-246x.1999.00967.x}}
!
! @ARTICLE{KoLiTrSuStSh04,
! author={Dimitri Komatitsch and Qinya Liu and Jeroen Tromp and Peter S\"{u}ss
!   and Christiane Stidham and John H. Shaw},
! year=2004,
! title={Simulations of Ground Motion in the {L}os {A}ngeles {B}asin
!   based upon the Spectral-Element Method},
! journal={Bull. Seism. Soc. Am.},
! volume=94,
! number=1,
! pages={187-206}}
!
! and/or another article from http://web.univ-pau.fr/~dkomati1/publications.html
!
!
! If you use the kernel capabilities of the code, please cite at least one article
! written by the developers of the package, for instance:
!
! @ARTICLE{TrKoLi08,
! author = {Jeroen Tromp and Dimitri Komatitsch and Qinya Liu},
! title = {Spectral-Element and Adjoint Methods in Seismology},
! journal = {Communications in Computational Physics},
! year = {2008},
! volume = {3},
! pages = {1-32},
! number = {1}}
!
! or
!
! @ARTICLE{LiTr06,
! author={Qinya Liu and Jeroen Tromp},
! title={Finite-frequency kernels based on adjoint methods},
! journal={Bull. Seismol. Soc. Am.},
! year=2006,
! volume=96,
! number=6,
! pages={2383-2397},
! doi={10.1785/0120060041}}
!
!
! Reference frame - convention:
! ----------------------------
!
! The code uses the following convention for the reference frame:
!
!  - X axis is East
!  - Y axis is North
!  - Z axis is up
!
! Note that this convention is different from both the Aki-Richards convention
! and the Harvard CMT convention.
!
! Let us recall that the Aki-Richards convention is:
!
!  - X axis is North
!  - Y axis is East
!  - Z axis is down
!
! and that the Harvard CMT convention is:
!
!  - X axis is South
!  - Y axis is East
!  - Z axis is up
!
! To report bugs or suggest improvements to the code, please send an email
! to Jeroen Tromp <jtromp AT princeton.edu> and/or use our online
! bug tracking system at http://www.geodynamics.org/roundup .
!

PARAMETERS TO CHANGE ON DIFFERENT MACHINES:

- Use the appropriate compiler flags in the Makefile.
  Set F90, MPIF90, FLAGS_NO_CHECK, FLAGS_CHECK and MPI_FLAGS.
  Also set C_PREPROCESSOR to activate C preprocessing
  in your Fortran compiler (see the manual of your Fortran compiler for the right syntax)
- In constants.h set LOCAL_PATH_IS_ALSO_GLOBAL flag.
  On clusters (e.g., Beowulfs), set this option to .false. in almost all cases.
- In constants.h set FIX_UNDERFLOW_PROBLEM flag
  (need to fix underflow trapping on some machines, e.g., Pentium processors)
- In Par_file set LOCAL_PATH (this is where databases are written and read)
- In precision.h choose single versus double precision (double precision
  doubles the memory requirements for the solver but may be faster)
- Also, in constants.h choose the CUSTOM_REAL size depending on
  single or double precision
- When running on an SGI, add "setenv TRAP_FPE OFF" to your .cshrc file
  before compiling, in order to turn underflow trapping off

SCRIPTS:

- go_mesher runs the mesher
  (need to set the correct mpirun command at the end of the script)
- go_solver runs the solver
  (need to set the correct mpirun command at the end of the script)
- runall compiles and runs both mesher and solver

MESH GENERATION

** With an external mesh generation tool such as CUBIT :

- Create the mesh of your model. 

- Export the mesh in the following format (for CUBIT, we provide Python scripts to facilitate this step) :

  nodes_coords_file : this contains the number of nodes on the first line, followed by the (x,y,z) coordinates for each node in meters.
       number of nodes 
       id_node x_coordinate y_coordinate z_coordinate 
       ..... 

  mesh_file : contains the number of elements on the first line, followed by the list of nodes (8 per element) that compose those elements. 
    format :
       number of elements 
       id_elements id_node1 id_node2 id_node3 id_node4 id_node5 id_node6 id_node7 id_node8 
       ..... 

  materials_file : associates an element with its material (an integer).
    format : 
       id_element flag 
       ....

  nummaterial_velocity_file : table of the material properties 
    flag rho vp vs 0 0                    #full definition of the properties, flag > 0 
    ..... 
    flag 'tomography' file_name      #for interpolation with tomography 
    ..... 
    flag 'interface' file_name flag_for_the_gll_below_the_interface flag_for_the_gll_above_the_interface #for 
    interpolation with interface 
    .... 

  absorbing_surface_file_xmin : contains all the face in the absorbing boundary defined by x=Xmin 
    format: 
       number of faces 
       id_(element containg the face) id_node1_face id_node2_face id_node3_face id_node4_face 
       .... 

       with the same format :
  absorbing_surface_file_xmax : contains all the face in the absorbing boundary defined by x=Xmax 
  absorbing_surface_file_ymin : contains all the face in the absorbing boundary defined by y=Ymin 
  absorbing_surface_file_ymax : contains all the face in the absorbing boundary defined by y=Ymax 
  absorbing_surface_file_bottom : contains all the face in the absorbing boundary defined by z=bottom 

  free_surface_file = file with the hex on the free surface (usually the topography) 
    format: 
       number of faces 
       id_(element containg the face) id_node1_face id_node2_face id_node3_face id_node4_face 
       ..... 

-  Partition the mesh with the standalone program decompose_mesh_SCOTCH that calls the Scotch library.  
   It writes files named after the rank of the MPI process that will process this part

** With meshfem3D:

- The mesher generate_databases needs NPROC processors.
- Note that NPROC = 1 is valid (in case you have a
  machine with a small number of processors). Therefore the code can
  if needed run serially on one processor only (in such a case,
  still link with MPI, and use "mpirun -np 1")
- In the Par_file, define the type of the mesh. The mesher and the solver
  can use UTM coordinates internally, therefore you also need to define
  the zone number for the UTM projection (e.g., zone 11 for Los Angeles).
  Use decimal values for latitude and longitude (no minutes/seconds).
  These values are approximate, the mesher will round them off to define
  a square mesh in UTM coordinates.

  UTM_PROJECTION_ZONE    ! zone of the UTM projection (e.g. 11 for Los Angeles)

CHECKING THE MESH (optional, after running the mesher):

- Use the serial code check_mesh_quality_AVS_DX
    ("make check_mesh_quality_AVS_DX" and then "xcheck_mesh_quality_AVS_DX")
    to generate an AVS output file ("AVSmeshquality.inp" in AVS UCD format)
    or an OpenDX output file ("DXmeshquality.dx")
    that can be used to investigate mesh quality, e.g., skewness of elements,
    and a Gnuplot histogram ("mesh_quality_histogram.txt") that can
    be plotted with gnuplot ("gnuplot plot_mesh_quality_histogram.gnu")

- Use the serial code combine_AVS_DX
    ("make combine_AVS_DX" and then "xcombine_AVS_DX")
    to generate AVS output files (in AVS UCD format) or OpenDX output files
    showing the mesh, the MPI partition (slices), the source and receiver
    location etc. Use the AVS UCD file AVS_coastline_freeways_LA.inp
    or the OpenDX file DX_coastline_freeways_LA.dx for reference
    in the Los Angeles area.

DATABASES GENERATOR (generate_databases):

- set all the parameters in DATA/Par_file, in particular the following:

  OCEANS                 ! to incorporate the effects of the oceans (cheap)
  ATTENUATION            ! to include attenuation (fairly expensive)
  ABSORBING_CONDITIONS   ! absorbing boundary conditions (cheap)
  SAVE_AVS_DX_MESH_FILES ! save mesh files for AVS users, www.avs.com,
    or OpenDX users, www.opendx.org). Do not use if you do not have AVS
    or OpenDX, because this option creates large files.

- Compile the databases generator ("make generate_databases") and run it 
  for instance with the go_mesher script
- Mesher output is provided in the OUTPUT_FILES directory in output_generate_databases.txt
    (output can be directed to the screen instead by uncommenting two lines
     in constants.h:
       ! uncomment this to write messages to the screen
       ! integer, parameter :: IMAIN = ISTANDARD_OUTPUT )
- For a given model and set of processors, one only needs to run the databases_generator
  once and for all
- The databases generator filters the list of stations in file DATA/STATIONS to exclude
  the stations that are not located within the region given in the Par_file
  (between LATITUDE_MIN and LATITUDE_MAX, and between LONGITUDE_MIN and LONGITUDE_MAX).
  The filtered file is called DATA/STATIONS_FILTERED
- When running benchmarks on rectangular models, one can turn the UTM projection
  off by using flag SUPPRESS_UTM_PROJECTION, in which case all "longitude"
  parameters simply refer to the X axis, and all "latitude" parameters
  simply refer to the Y axis.

SOLVER (specfem3D):

- For reasons of speed, the solver uses static memory allocation. Therefore it
  needs to be recompiled every time one reruns the mesher. The mesher uses
  dynamic allocation only, and does not need to be recompiled.
- The solver needs NPROC processors (same as the mesher)
- The solver needs the DATA/CMTSOLUTION file for the source and the
  DATA/STATIONS file for the list of stations
- Set the "time shift" in the CMTSOLUTION file to 0.0
    (the solver will not run otherwise)
- To simulate a delta source-time function, set "half duration" in
  the CMTSOLUTION file to 0.0. If "half duration" is not zero,
  the code will use a Gaussian (not too different from triangular)
  source-time function with half-width "half duration". We prefer to run
  the solver with "half duration" set to zero and convolve after the fact,
  because this way it's easy to use a variety of source-time functions.
  Use the serial code convolve_source_timefunction.f90 and the script
  convolve_source_timefunction.csh for this purpose. (Set the parameter "hdur"
  in convolve_source_timefunction.csh to the desired half-duration.)
  (type "make convolve_source_timefunction" to compile the code).
- To simulate multiple events, set the parameter NSOURCES in the DATA/Par_file
    to the desired number. Provide a CMTSOLUTION file that has NSOURCES entries,
    one for each CMT solution (i.e., concatenate NSOURCES CMTSOLUTION files
    to a single CMTSOLUTION file). At least one entry should have a zero "time shift",
    and all the other entries should have non-negative "time shift". Each event
    can have its own half duration, latitude, longitude, depth and moment tensor.
    This feature can also be used to mimic the directivity associated with a
    finite source.
- Solver output is provided in the OUTPUT_FILES directory in output_solver.txt
    (output can be directed to the screen instead by uncommenting two lines
     in constants.h:
       ! uncomment this to write messages to the screen
       ! integer, parameter :: IMAIN = ISTANDARD_OUTPUT )
- If you have a fast machine, set NTSTEP_BETWEEN_OUTPUT_INFO
    to a relatively high value (e.g. at least 100, or even 1000 or more)
    to avoid writing to the output text files too often. Same thing
    with NTSTEP_BETWEEN_OUTPUT_SEISMOS.
- On clusters (e.g., Beowulfs) the seismogram files are distributed on the
    local disks (option LOCAL_PATH_IS_ALSO_GLOBAL turned off) and need to be
    gathered at the end of the simulation
- For the same model, rerun the solver for different events by changing the
  CMTSOLUTION file, or for different stations by changing the STATIONS file.
  There is no need to rerun the mesher. It is best to include as many stations
  as possible, since this does not add to the cost of the simulation.

MOVIE OF THE RESULTS:

- Use create_movie_AVS_DX.f90 ("make create_movie_AVS_DX") to create
    a movie of surface displacement (vertical component) or of the entire
    3D wave field. The movie can be saved in OpenDX, AVS or GMT format.
    Set parameters MOVIE_SURFACE, MOVIE_VOLUME, and NTSTEP_BETWEEN_FRAMES
    in the Par_file. Remember to use a DATA/CMTSOLUTION source file
    with a half-duration hdur > 0, otherwise you will get a movie
    corresponding to a Heaviside source, with a lot of high-frequency noise.
    Note that this option creates large files!
    Also set CREATE_SHAKEMAP is you want to create a ShakeMap at the end
    of the simulation.

SERIAL RUNS (WITHOUT MPI):

On a large serial machine, one may want to run a serial version of the code without MPI.
To do this, one needs to:

- set NPROC = 1 in DATA/Par_file
- type "make generate_databases_serial" and "make specfem3D_serial" instead of
    "make generate_databases" and "make specfem3D"
- run the code serially with "./xgenerate_databases" and "./xspecfem3D"

BUG REPORTS:

To report bugs or suggest improvements to the code, please send an email
to Jeroen Tromp <jtromp AT princeton.edu> and/or use our online
bug tracking system at http://www.geodynamics.org/roundup .

Note: The Gauss-Lobatto subroutines in gll_library.f90 are based in part on
      software libraries from M.I.T., Department of Mechanical Engineering.

Note: The non-structured global numbering software was provided by Paul F. Fischer.

Note: Subroutines from "Numerical Recipes: The Art of Scientific Computing"
      by W. H. Press et al., Cambridge University Press, are used in
      numerical_recipes.f90. The user must acquire an official
      Numerical Recipes license to run them.

Note: Subroutine utm_geo.f90 contains UTM (Universal Transverse Mercator)
      projection software from the USGS.

Note: AVS is a trademark of Advanced Visualization Systems, www.avs.com
      OpenDX is based on IBM Data Explorer, www.opendx.org

