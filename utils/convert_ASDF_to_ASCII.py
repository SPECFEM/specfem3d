#!/usr/bin/env python
#
# reads in an ASDF-format file generated by SPECFEM and outputs ASCII files for each trace
#
"""
usage: ./convert_ASDF_to_ASCII.py file_in

  with file_in - input ASDF-format file, e.g., OUTPUT_FILES/synthetic.h5

"""
from __future__ import print_function

import sys,os
import numpy as np

# based on pyasdf reader
try:
    import pyasdf
except:
    print("Error importing pyasdf, check if pyasdf module is installed")
    print("")
    # python version
    print("python version:")
    print(sys.version)
    print("")
    # import module paths
    print("module paths:")
    for path in sys.path:
        print(path)
    print("")
    sys.exit(1)

# arguments
try:
    file_in = sys.argv[1]
except:
    print(__doc__)
    sys.exit(1)

# takes same output directory as input file
# for example: ./convert_ASDF_to_ASCII.py OUTPUT_FILES/synthetic.h5
#              -> output in OUTPUT_FILES/ directory
out_dir = os.path.dirname(file_in)
if out_dir == '':
    out_dir = "./"  # -> ./ + DB.STA.XXX.semd
else:
    out_dir = out_dir + "/"  # OUTPUT_FILES -> OUTPUT_FILES/ + DB.STA.XXX.semd

# reads input file
print("")
print("reading file: ",file_in)
print("")

ds = pyasdf.ASDFDataSet(file_in)

# event time
has_event_time = False
if len(ds.events) > 0:
    # taken from first event given
    if len(ds.events[0].origins) > 0:
        # UTC time of first origin specified
        cmt_time = ds.events[0].origins[0].time
        has_event_time = True

if has_event_time: print("event CMT time: ",cmt_time)

# station info
stations = ds.waveforms
print("")
print("traces:")
print("  number of stations: ",len(stations))
print("")
print(stations.list())
print("")

# timing
# how long it takes to determine minimum and maximum values in an array
from timeit import default_timer

def minmax_np(xy):
    # uses numpy internal functions
    minval = np.min(xy[:,1])
    maxval = np.max(xy[:,1])
    return (minval,maxval)

def minmax(xy):
    # combines loop over all elements to determine min/max at the same time
    minval = xy[0,1]
    maxval = xy[0,1]
    for f1 in xy[1:,1]:
        if f1 > maxval:
            maxval = f1
        elif f1 < minval:
            minval = f1
    return (minval, maxval)

def minmax2(xy):
    # combines loop over all elements and takes steps of 2 to minimize number of comparisons
    minval = xy[0,1]
    maxval = xy[0,1]
    if len(xy[:,1]) % 2 == 0:
      istart = 0
    else:
      istart = 1
    for ii in xrange(0, len(xy[:,1]), 2):
        f1 = xy[ii  ,1]
        f2 = xy[ii+1,1]
        if (f1 < f2):
            if f1 < minval: minval = f1
            if f2 > maxval: maxval = f2
        else:
            if f2 < minval: minval = f2
            if f1 > maxval: maxval = f1
    return (minval, maxval)


for station in stations.list():
    print("")
    print("station: ",station)

    # waveform data
    data_station = stations[station]

    #debug
    #print("waveform list:",sta.list())
    #print("waveform tags:",sta.get_waveform_tags())
    #print("")

    # streams within waveform data
    st = data_station.synthetic

    # prints traces
    for i,tr in enumerate(st):
        # gets station/network name
        net = tr.stats.network    # e.g. DB
        sta = tr.stats.station    # e.g. Z1
        cha = tr.stats.channel    # e.g. FXX

        # file output
        # name format: <output_dir>/<net>.<sta>.<cha>.semd
        #              e.g. OUTPUT_FILES/DB.Z1.FXX.semd
        # assuming by default that waveforms are displacement
        # otherwise, user will need to rename the file endings
        filename = out_dir + "{}.{}.{}.semd".format(net,sta,cha)
        print("  trace output to file: ",filename)

        # length
        length = len(tr.data)

        # onset time of the simulation would be the difference between
        # the trace's start time and the event CMT time
        if has_event_time:
            onset_time = tr.stats.starttime
            t0 = onset_time - cmt_time
        else:
            t0 = 0.0      # we don't know the onset time
        print("  t0: ",t0)

        # time sampling
        dt = tr.stats.delta
        print("  length = ",length," dt = ",dt)

        # file output
        f = open(filename, "w")

        # ascii file header
        f.write("# NETWORK %s\n" % (net))
        f.write("# STATION %s\n" % (sta))
        f.write("# CHANNEL %s\n" % (cha))
        f.write("# START_TIME %s\n" % (str(tr.stats.starttime)))
        f.write("# SAMP_FREQ %f\n" % (tr.stats.sampling_rate))
        f.write("# NDAT %d\n" % (tr.stats.npts))

        # data section
        # fills numpy array
        xy = np.empty(shape=(0,2))
        for ii in range(length):
            time = ii*dt + t0
            xy = np.append(xy,[[time,tr.data[ii]]],axis=0)

        # data column
        #print(xy[:,1])
        #print(xy[0,1],xy[1,1],xy[2,1],xy[3,1])

        # saves as ascii
        np.savetxt(f, xy, fmt="%f\t%f")
        f.close()

        # statistics
        #start = default_timer()
        minval,maxval = minmax_np(xy)   # 7.414818e-05 s
        #minval,maxval = minmax(xy)     # 6.389618e-04 s
        #minval,maxval = minmax2(xy)    # 1.811981e-03 s
        #end = default_timer()
        #print("  min/max = %f / %f  (timing: %e s)" %(minval,maxval,end-start))
        print("  min/max = %f / %f" %(minval,maxval))
        print("")

# figure output
#st.plot()


